<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Pipeline CPU :: Ther&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="流水线计算公式 $n$为指令数，$k$为流水线级数，级间延时$\Delta t$。
实际吞吐率（单位时间内流水线处理的指令数）： $$ TP=\frac{n}{(k&#43;n-1)\Delta t} $$ 最大吞吐率： $$ TP_{max} = \frac{1}{\Delta t} $$ 实际加速比： $$ S = \frac{kn}{k&#43;n-1} $$ 最大加速比： $$ S_{max}=k $$
流水线中控制信号的流动 控制信号在IF之后的ID/RF阶段产生。
 ID/RF：Extop EX：ALUSrc、ALUOp、RegDst？？ MEM：MemWrite、Branch WB：MemToReg、RegWrite  流水线中的冒险 首先列出未冒险时流水线CPU在各步中进行的操作：
    R lw or sw beq J     IF PC&amp;lt;=PC&#43;4; IR &amp;lt;=MemInst[PC] * * *   ID opcode&amp;lt;=IR[31:26]; A&amp;lt;=Reg[IR[25:21]]; B&amp;lt;=Reg[IR[20:16]]; ALUOut&amp;lt;=PC&#43;(signext(IR[15:0]&amp;lt;&amp;lt;2)) * * PC &amp;lt;= {PC[31:28],IR[25:0],2’b00}   EX ALUOut &amp;lt;= A op B ALUOut&amp;lt;=A&#43;sign-ext(IR[15:0]) if (A=B)PC&amp;lt;=ALUOut    MEM Reg[IR[15:11]]&amp;lt;=ALUOut Lw:MDR&amp;lt;=MemData[ALUOut];Sw:MemData[ALUout] &amp;lt;=B     WB  Reg[IR[20:16]] &amp;lt;=MDR      结构冒险 problem 流水线处理器中直接取消了InstMemory和DataMemory混用的做法，因此不必担心存储器访问的冲突。" />
<meta name="keywords" content="study" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/pipeline_cpu/" />




<link rel="stylesheet" href="https://ther-nullptr.github.io/assets/style.css">

  <link rel="stylesheet" href="assets/%25!s%28%3cnil%3e%29.css">






<link rel="apple-touch-icon" href="https://ther-nullptr.github.io/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://ther-nullptr.github.io/">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Pipeline CPU">
<meta property="og:description" content="流水线计算公式 $n$为指令数，$k$为流水线级数，级间延时$\Delta t$。
实际吞吐率（单位时间内流水线处理的指令数）： $$ TP=\frac{n}{(k&#43;n-1)\Delta t} $$ 最大吞吐率： $$ TP_{max} = \frac{1}{\Delta t} $$ 实际加速比： $$ S = \frac{kn}{k&#43;n-1} $$ 最大加速比： $$ S_{max}=k $$
流水线中控制信号的流动 控制信号在IF之后的ID/RF阶段产生。
 ID/RF：Extop EX：ALUSrc、ALUOp、RegDst？？ MEM：MemWrite、Branch WB：MemToReg、RegWrite  流水线中的冒险 首先列出未冒险时流水线CPU在各步中进行的操作：
    R lw or sw beq J     IF PC&amp;lt;=PC&#43;4; IR &amp;lt;=MemInst[PC] * * *   ID opcode&amp;lt;=IR[31:26]; A&amp;lt;=Reg[IR[25:21]]; B&amp;lt;=Reg[IR[20:16]]; ALUOut&amp;lt;=PC&#43;(signext(IR[15:0]&amp;lt;&amp;lt;2)) * * PC &amp;lt;= {PC[31:28],IR[25:0],2’b00}   EX ALUOut &amp;lt;= A op B ALUOut&amp;lt;=A&#43;sign-ext(IR[15:0]) if (A=B)PC&amp;lt;=ALUOut    MEM Reg[IR[15:11]]&amp;lt;=ALUOut Lw:MDR&amp;lt;=MemData[ALUOut];Sw:MemData[ALUout] &amp;lt;=B     WB  Reg[IR[20:16]] &amp;lt;=MDR      结构冒险 problem 流水线处理器中直接取消了InstMemory和DataMemory混用的做法，因此不必担心存储器访问的冲突。" />
<meta property="og:url" content="https://ther-nullptr.github.io/posts/digital_logic_and_processors/pipeline_cpu/" />
<meta property="og:site_name" content="Ther&#39;s Blog" />

  
    <meta property="og:image" content="https://ther-nullptr.github.io/">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

  <meta property="article:section" content="study" />


  <meta property="article:published_time" content="2022-05-31 00:00:00 &#43;0000 UTC" />












</head>
<body class="">


<div class="container headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://ther-nullptr.github.io/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/posts/">Home</a></li>
        
      
        
          <li><a href="/about/">About</a></li>
        
      
        
          <li><a href="/archives/">Archives</a></li>
        
      
        
          <li><a href="/search/">Search</a></li>
        
      
        
          <li><a href="/links/">Links</a></li>
        
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/posts/">Home</a></li>
      
    
      
        <li><a href="/about/">About</a></li>
      
    
      
        <li><a href="/archives/">Archives</a></li>
      
    
      
        <li><a href="/search/">Search</a></li>
      
    
      
        <li><a href="/links/">Links</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/pipeline_cpu/">Pipeline CPU</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2022-05-31
        
      </span>
    
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://ther-nullptr.github.io/tags/digital-logic-and-processors/">digital logic and processors</a>&nbsp;
    
  </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="流水线计算公式">流水线计算公式<a href="#流水线计算公式" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>$n$为指令数，$k$为流水线级数，级间延时$\Delta t$。</p>
<p>实际吞吐率（单位时间内流水线处理的指令数）：
$$
TP=\frac{n}{(k+n-1)\Delta t}
$$
最大吞吐率：
$$
TP_{max} = \frac{1}{\Delta t}
$$
实际加速比：
$$
S = \frac{kn}{k+n-1}
$$
最大加速比：
$$
S_{max}=k
$$</p>
<h1 id="流水线中控制信号的流动">流水线中控制信号的流动<a href="#流水线中控制信号的流动" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>控制信号在IF之后的ID/RF阶段产生。</p>
<ul>
<li>ID/RF：Extop</li>
<li>EX：ALUSrc、ALUOp、<strong>RegDst</strong>？？</li>
<li>MEM：MemWrite、Branch</li>
<li>WB：MemToReg、RegWrite</li>
</ul>
<h1 id="流水线中的冒险">流水线中的冒险<a href="#流水线中的冒险" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>首先列出未冒险时流水线CPU在各步中进行的操作：</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>lw or sw</th>
<th>beq</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td><code>PC&lt;=PC+4; IR &lt;=MemInst[PC]</code></td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>ID</td>
<td><code>opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]];</code> <strong><code>ALUOut&lt;=PC+(signext(IR[15:0]&lt;&lt;2))</code></strong></td>
<td>*</td>
<td>*</td>
<td><code>PC &lt;= {PC[31:28],IR[25:0],2’b00}</code></td>
</tr>
<tr>
<td>EX</td>
<td><strong><code>ALUOut &lt;= A op B</code></strong></td>
<td><strong><code>ALUOut&lt;=A+sign-ext(IR[15:0])</code></strong></td>
<td><code>if (A=B)PC&lt;=ALUOut</code></td>
<td></td>
</tr>
<tr>
<td>MEM</td>
<td><strong><code>Reg[IR[15:11]]&lt;=ALUOut</code></strong></td>
<td><code>Lw:MDR&lt;=MemData[ALUOut];Sw:MemData[ALUout] &lt;=B</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WB</td>
<td></td>
<td><strong><code>Reg[IR[20:16]] &lt;=MDR</code></strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="结构冒险">结构冒险<a href="#结构冒险" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="problem">problem<a href="#problem" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>流水线处理器中直接取消了InstMemory和DataMemory混用的做法，因此不必担心存储器访问的冲突。</p>
<ol>
<li>ALU使用冲突。考虑下列指令：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$t0</span><span class="p">,</span><span class="no">$t1</span><span class="p">,</span><span class="no">$t2</span>
</span></span><span class="line"><span class="cl"><span class="nf">beq</span> <span class="no">$a0</span><span class="p">,</span><span class="no">$a1</span><span class="p">,</span><span class="no">label</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当add指令执行完EX时，beq指令执行完ID，ALU产生冲突的结果。</p>
<ol start="2">
<li>寄存器堆写入冲突。考虑下列指令：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">lw</span> <span class="no">$a0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="no">$t0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$t0</span><span class="p">,</span><span class="no">$t1</span><span class="p">,</span><span class="no">$t2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当add指令执行完MEM时，lw指令执行完WB，寄存器写入数据产生冲突的结果。</p>
<h3 id="solution">solution<a href="#solution" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>
<p>ALU使用冲突：</p>
<p>beq指令原先需要进行两次计算操作：1)在ID阶段计算分支地址 2)在EX阶段作差比较，更新PC。</p>
<p>现在需要将计算分支地址移动到EX阶段，把ALUOut计算分解为ALU和PCAdd（一个周期进行两次计算），在MEM阶段更新PC。</p>
</li>
<li>
<p>寄存器堆写入冲突：</p>
<p>将R型的Write back移动到WB阶段。</p>
</li>
</ol>
<p>更新后的操作如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>lw or sw</th>
<th>beq</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td><code>PC&lt;=PC+4; IR &lt;=MemInst[PC];</code></td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>ID</td>
<td><code>opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]];</code></td>
<td>*</td>
<td>*</td>
<td><code>PC &lt;= {PC[31:28],IR[25:0],2’b00}</code></td>
</tr>
<tr>
<td>EX</td>
<td><code>ALUOut &lt;= A op B</code></td>
<td><code>ALUOut&lt;=A+sign-ext(IR[15:0])</code></td>
<td><code>ALUOut&lt;=A-B; PCAdd&lt;=PC+(signext(IR[15:0]&lt;&lt;2))</code></td>
<td></td>
</tr>
<tr>
<td>MEM</td>
<td></td>
<td><code>Lw:MDR&lt;=MemData[ALUOut]; Sw:MemData[ALUout] &lt;=B</code></td>
<td><code>if(Zero) PC&lt;=PCAdd</code></td>
<td></td>
</tr>
<tr>
<td>WB</td>
<td><code>Reg[IR[15:11]]&lt;=ALUOut</code></td>
<td><code>Reg[IR[20:16]] &lt;=MDR</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数据冒险">数据冒险<a href="#数据冒险" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>无法得到所需的数据而导致不能执行后续指令。数据冒险面对的是<strong>操作数是否已经更新</strong>的问题。</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>lw or sw</th>
<th>beq</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td><code>PC&lt;=PC+4; IR &lt;=MemInst[PC];</code></td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>ID</td>
<td><code>opcode&lt;=IR[31:26];</code> <strong><code>A&lt;=Reg[IR[25:21]];</code></strong> <strong><code>B&lt;=Reg[IR[20:16]];</code></strong></td>
<td>*</td>
<td>*</td>
<td><code>PC &lt;= {PC[31:28],IR[25:0],2’b00}</code></td>
</tr>
<tr>
<td>EX</td>
<td><code>ALUOut &lt;= A op B</code></td>
<td><code>ALUOut&lt;=A+sign-ext(IR[15:0])</code></td>
<td><code>ALUOut&lt;=A-B; PCAdd&lt;=PC+(signext(IR[15:0]&lt;&lt;2))</code></td>
<td></td>
</tr>
<tr>
<td>MEM</td>
<td></td>
<td><code>Lw:MDR&lt;=MemData[ALUOut]; Sw:MemData[ALUout] &lt;=B</code></td>
<td><code>if(Zero) PC&lt;=PCAdd</code></td>
<td></td>
</tr>
<tr>
<td>WB</td>
<td><strong><code>Reg[IR[15:11]]&lt;= ALUOut</code></strong></td>
<td><strong><code>Reg[IR[20:16]] &lt;= MDR</code></strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="read-after-write-data-hazardsraw">Read after write data hazards(RAW)<a href="#read-after-write-data-hazardsraw" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="硬件优化">硬件优化<a href="#硬件优化" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>考虑以下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$r1</span><span class="p">,</span><span class="no">$r2</span><span class="p">,</span><span class="no">$r3</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$r2</span><span class="p">,</span><span class="no">$r1</span><span class="p">,</span><span class="no">$r3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>before:</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add $r1,$r2,$r3</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add $r2,$r1,$r3</code></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
</tr>
</tbody>
</table>
<p>注意到第一条指令在WB阶段将结果写回寄存器（注意已经不是MEM阶段了！），而第二条指令在ID阶段读取寄存器。可以不修改数据通路，但是需要保证寄存器先写后读（否则需要阻塞3个周期）。</p>
<blockquote>
<p>实现方法：</p>
<ol>
<li>流水线上的寄存器在上升沿时写入，在时钟的下降沿写入寄存器堆。</li>
<li>比较写入地址和读取地址，当两者相同且要写入寄存器堆时，读取端的数据直接选择为写入端的数据而不从寄存器堆中读取。</li>
</ol>
</blockquote>
<h4 id="forward转发">Forward(转发)<a href="#forward转发" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>考虑以下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$r1</span><span class="p">,</span><span class="no">$r2</span><span class="p">,</span><span class="no">$r3</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span> <span class="no">$r4</span><span class="p">,</span><span class="no">$r1</span><span class="p">,</span><span class="no">$r5</span>
</span></span><span class="line"><span class="cl"><span class="nf">and</span> <span class="no">$r6</span><span class="p">,</span><span class="no">$r1</span><span class="p">,</span><span class="no">$r7</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>after:</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add $r1,$r2,$r3</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sub $r4,$r1,$r5</code></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
</tr>
<tr>
<td><code>and $r6,$r1,$r7</code></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
</tr>
</tbody>
</table>
<p>指令1在WB阶段写入r1寄存器，但指令2、3在ID阶段就要用到r1。不过实际上在指令的EX阶段该数值就已经计算完毕，需要在指令2、3的EX阶段用到。</p>
<p>对于指令2，EX的操作数来源于EX/MEM.ALUOut；对于指令3，EX的操作数来源于MEM/WB.ALUOut；</p>
<h3 id="load-use-data-hazardlw-calculate-type">Load-use data hazard(lw-calculate type)<a href="#load-use-data-hazardlw-calculate-type" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="forward">Forward<a href="#forward" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>考虑以下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">lw</span> <span class="no">$r1</span><span class="p">,</span><span class="mi">100</span><span class="p">(</span><span class="no">$r2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span> <span class="no">$r4</span><span class="p">,</span><span class="no">$r1</span><span class="p">,</span><span class="no">$r5</span>
</span></span><span class="line"><span class="cl"><span class="nf">and</span> <span class="no">$r6</span><span class="p">,</span><span class="no">$r1</span><span class="p">,</span><span class="no">$r7</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>before:</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lw $r1,100($r2)</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sub $r4,$r1,$r5</code></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
</tr>
<tr>
<td><code>and $r6,$r1,$r7</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
</tr>
</tbody>
</table>
<p><em>after:</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lw $r1,100($r2)</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sub $r4,$r1,$r5</code></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
</tr>
<tr>
<td><code>and $r6,$r1,$r7</code></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
</tr>
</tbody>
</table>
<p>lw后r1的新值在MEM阶段后产生，随后被转发至MDR（注意此处的MDR与多周期中的MDR不同，此处的MDR应该是MEM/WB的一部分）中，在下个周期供sub的EX阶段使用。</p>
<p>上述方法必须使用一次stall，可以重排指令，在lw之后运行一条不依赖r1寄存器的指令。</p>
<p>更新后的操作如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>lw or sw</th>
<th>beq</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td>PC&lt;=PC+4; IR &lt;=MemInst[PC];</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>ID</td>
<td>opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]];</td>
<td>*</td>
<td>*</td>
<td>PC &lt;= {PC[31:28],IR[25:0],2’b00}</td>
</tr>
<tr>
<td>EX</td>
<td>ALUOut &lt;= A op B; (Register,EX/MEM.ALUOut,MEM/WB.ALUOut,MDR)</td>
<td>ALUOut&lt;=A+sign-ext(IR[15:0]); (Register,EX/MEM.ALUOut,MEM/WB.ALUOut,MDR)</td>
<td>ALUOut&lt;=A-B; PCAdd&lt;=PC+(signext(IR[15:0]&laquo;2))</td>
<td></td>
</tr>
<tr>
<td>MEM</td>
<td></td>
<td>Lw:MDR&lt;=MemData[ALUOut]; Sw:MemData[ALUout] &lt;=B</td>
<td>if(Zero) PC&lt;=PCAdd</td>
<td></td>
</tr>
<tr>
<td>WB</td>
<td>Reg[IR[15:11]]&lt;=ALUOut</td>
<td>Reg[IR[20:16]] &lt;=MDR</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="load-use-data-hazardlw-sw-type">Load-use data hazard(lw-sw type)<a href="#load-use-data-hazardlw-sw-type" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>考虑以下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">lw</span> <span class="no">$a0</span><span class="p">,</span><span class="mi">10</span><span class="p">(</span><span class="no">$a1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">sw</span> <span class="no">$a0</span><span class="p">,</span><span class="mi">10</span><span class="p">(</span><span class="no">$a2</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>before</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lw $a0,10($a1)</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sw $a0,10($a2)</code></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
</tr>
</tbody>
</table>
<p><em>after</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lw $a0,10($a1)</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>sw $a0,10($a2)</code></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
</tr>
</tbody>
</table>
<p>lw在MEM阶段结束后更新a0的值，此时可以直接转发给sw，以供在下一时钟周期存入存储器。</p>
<blockquote>
<p>注意与以下情景做区分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">lw</span> <span class="no">$t4</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">$t0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">sw</span> <span class="no">$t0</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">$t4</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就不是lw-sw type了，解决方案见lw-calculate type。</p>
</blockquote>
<h2 id="控制冒险">控制冒险<a href="#控制冒险" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>取到的指令可能不是所需要的，导致指令不能在预定的时钟周期内执行。控制冒险面对的是<strong>下一条指令的PC是多少</strong>的问题。</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>lw or sw</th>
<th>beq</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td><strong>PC&lt;=PC+4</strong>; IR &lt;=MemInst[PC];</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>ID</td>
<td>opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]];</td>
<td>*</td>
<td>*</td>
<td><strong>PC &lt;= {PC[31:28],IR[25:0],2’b00}</strong></td>
</tr>
<tr>
<td>EX</td>
<td>ALUOut &lt;= A op B; (Register,EX/MEM.ALUOut,MEM/WB.ALUOut,MDR)</td>
<td>ALUOut&lt;=A+sign-ext(IR[15:0]); (Register,EX/MEM.ALUOut,MEM/WB.ALUOut,MDR)</td>
<td>ALUOut&lt;=A-B; PCAdd&lt;=PC+(signext(IR[15:0]&laquo;2))</td>
<td></td>
</tr>
<tr>
<td>MEM</td>
<td></td>
<td>Lw:MDR&lt;=MemData[ALUOut]; Sw:MemData[ALUout] &lt;=B(B,MEM/WB.MemReadData)</td>
<td>if(Zero) <strong>PC&lt;=PCAdd</strong></td>
<td></td>
</tr>
<tr>
<td>WB</td>
<td>Reg[IR[15:11]]&lt;=ALUOut</td>
<td>Reg[IR[20:16]] &lt;=MDR</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="beq-hazard">beq hazard<a href="#beq-hazard" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>考虑如下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">beq</span> <span class="no">$t1</span><span class="p">,</span><span class="no">$t2</span><span class="p">,</span><span class="mi">0x10</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$a3</span><span class="p">,</span><span class="no">$a2</span><span class="p">,</span><span class="no">$a1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>before:</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>beq $t1,$t2,0x10</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add $a3,$a2,$a1</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
</tr>
</tbody>
</table>
<p>beq在MEM阶段才执行跳转，在WB阶段将目标地址写入PC，写入PC后下一条指令在IF阶段取用PC，默认情况下需要stall 3个周期，否则下一条指令执行可能会发生错误。</p>
<p>但实际上判断是否需要跳转的所有条件在EX阶段执行后就可以全部掌握，可以将ALUOut转发的结果转发至IF，这样只需要stall 2个周期。</p>
<p><em>after(v1):</em></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>beq $t1,$t2,0x10</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add $a3,$a2,$a1</code></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
</tr>
</tbody>
</table>
<p>实际上，也可以将分支判断移动到ID阶段：</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>lw or sw</th>
<th>beq</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td>PC&lt;=PC+4; IR &lt;=MemInst[PC];</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>ID</td>
<td>opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]];</td>
<td>*</td>
<td>if(A==B) PC&lt;=PC+(signext(IR[15:0]&laquo;2))</td>
<td>PC &lt;= {PC[31:28],IR[25:0],2’b00}</td>
</tr>
<tr>
<td>EX</td>
<td>ALUOut &lt;= A op B; (Register,EX/MEM.ALUOut,MEM/WB.ALUOut,MDR)</td>
<td>ALUOut&lt;=A+sign-ext(IR[15:0]); (Register,EX/MEM.ALUOut,MEM/WB.ALUOut,MDR)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MEM</td>
<td></td>
<td>Lw:MDR&lt;=MemData[ALUOut]; Sw:MemData[ALUout] &lt;=B(B,MEM/WB.MemReadData)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>WB</td>
<td>Reg[IR[15:11]] &lt;=ALUOut</td>
<td>Reg[IR[20:16]] &lt;=MDR</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>但是可能会带来一些新的问题：</p>
<ol>
<li>
<p>在EX阶段我们使用ALU比较两个操作数是否相等，使用PCAdder计算分支地址，所以现在需要在ID阶段额外引入比较器和PC计算器。注意到数据可能来自旁路。</p>
</li>
<li>
<p>在ID阶段判断beq，等价于将beq的EX阶段提前进行，这样就会产生3种情况：</p>
<ul>
<li>beq前1条指令为R type指令，stall 1个周期（1EX-&gt;2ID）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add $a3,$a2,$a1</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>beq $t0,$a3,0x10</code></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
</tr>
</tbody>
</table>
<ul>
<li>beq前1条指令为lw指令，stall 2个周期（1MEM-&gt;2ID）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lw $a3,0($a2)</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>beq $t0,$a3,0x10</code></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
</tr>
</tbody>
</table>
<ul>
<li>beq前2条指令为lw指令，stall 1个周期（1MEM-&gt;3ID）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lw $a3,0($a2)</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add $t3,$t2,$t1</code></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
</tr>
<tr>
<td><code>nop</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>beq $t0,$a3,0x10</code></td>
<td></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="延迟槽技术">延迟槽技术<a href="#延迟槽技术" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>即使将beq的判断前移到ID阶段，在beq之后也必须stall一个周期。可以在stall周期内执行一些必定要执行的指令，这就是<strong>延迟槽技术</strong>。</p>
<p>无特殊说明使用延迟槽技术的情况下，即使beq后面的指令必定执行，也必须要stall。</p>
<h4 id="预测">预测<a href="#预测" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<ul>
<li>静态预测：总预测分支不执行或者执行，错误则撤销指令。若预测失误会导致不必要的流水线重置。</li>
<li>动态预测：在IF阶段进行分支预测缓存，可以用PC（或者PC的低位地址）为索引，记录过去是否跳转。</li>
</ul>
<blockquote>
<p>实现过程：</p>
<ol>
<li>
<p>clock 1(IF):</p>
<p>在第一次执行beq指令时，建立BHT和BTB，并存下1)指令地址 2)最终是否跳转 3)跳转目标地址；在之后执行beq指令时，查询指令地址是否在BHT和BTB中，若不存在，建立新的条目；若存在，根据历史记录判断是否跳转；若跳转，取出目标地址作为下一条指令的IF地址。</p>
</li>
<li>
<p>clock 2(ID):</p>
<p>根据预测目标地址取出指令。</p>
</li>
</ol>
</blockquote>
<h3 id="j-hazard">j hazard<a href="#j-hazard" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>考虑如下指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">j</span> <span class="no">label</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$t3</span><span class="p">,</span><span class="no">$t1</span><span class="p">,</span><span class="no">$t2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>j label</code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>stall</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add $a3,$a2,$a1</code></td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
</tr>
</tbody>
</table>
<p>j在ID阶段完成目标地址的计算，需要stall一个周期。</p>
<p>**但这种做法是错误的！**因为流水线直到ID阶段才能知道取出的指令为j，而此时下一条指令只能已经从指令存储中取出，<strong>只能延后执行，而不能不执行</strong>。</p>
<p>于是我们不进行硬件阻塞。j指令执行完ID阶段时，可以判断出执行的是j指令，此时下一条指令（实际上不会执行）也执行完IF阶段，但之后的步骤都会被flush掉，ID阶段生成的新地址也被用于载入下下一条指令。从时间上看还是stall了一个周期。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>j label </code></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add $a3,$a2,$a1</code>(next)</td>
<td></td>
<td>IF</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td><code>add $a3,$a2,$a1</code>(jump target)</td>
<td></td>
<td></td>
<td>IF</td>
<td>ID</td>
<td>EX</td>
<td>MEM</td>
<td>WB</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>转发方式总结</strong></p>
<ul>
<li>数据冒险</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/15/IBAWylfu5XLO8Eg.png" alt="转发1"></p>
<ul>
<li>A2-&gt;B1 R型的前前条为R型</li>
<li>A3-&gt;B1 R型的前条为R型</li>
<li>A4-&gt;B2 lw-sw转发</li>
</ul>
<p>此外，A4-&gt;B1无法转发，对应于lw-R型必须stall一个周期。</p>
<ul>
<li>控制冒险(beq)</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/15/DFGkKoyB5pOgaLM.png" alt="转发2"></p>
<ul>
<li>A2-&gt;B0 beq的前前条为R型，可以使用转发解决</li>
<li>A3-&gt;B0 beq的前前条为lw，需要stall 2个周期</li>
<li>A4-&gt;B0 beq的前条为R型，需要stall 1个周期</li>
<li>A5-&gt;B0 beq的前条为lw型，需要stall 2个周期</li>
</ul>
<p>注意在转发时不能跨时钟周期转发，比如上上条指令ALU的结果输出不能直接转发，必须要经过MEM/WB寄存器。</p>
</blockquote>
<h1 id="考虑冒险的数据通路设计">考虑冒险的数据通路设计<a href="#考虑冒险的数据通路设计" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="forward-unit">Forward Unit<a href="#forward-unit" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="r-r-type1">R-R type(1)<a href="#r-r-type1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>若R型的前条为R型，则可能需要从EX_MEM寄存器中转发至EX阶段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrite</span> <span class="c1">// 需要写入寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="mh">0</span><span class="p">)</span> <span class="c1">// 不能使用0寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">==</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRs</span><span class="p">))</span> <span class="c1">// 触发转发条件（如果不使用转发就会冒险）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ForwardA</span> <span class="o">=</span> <span class="mh">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrite</span> 
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="mh">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">==</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRt</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="n">ForwardB</span> <span class="o">=</span> <span class="mh">10</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="r-r-type2">R-R type(2)<a href="#r-r-type2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>若R型的前前条为R型，则可能需要从MEM_WB寄存器中转发至EX阶段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrite</span>
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="mh">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">==</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRs</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRs</span> <span class="o">||</span> <span class="o">~</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrite</span><span class="p">)</span> <span class="c1">// 从前条转发的条件不满足
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardA</span> <span class="o">=</span> <span class="mh">01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrite</span>
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="mh">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">==</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRt</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRt</span> <span class="o">||</span> <span class="o">~</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrite</span><span class="p">)</span> <span class="c1">// 从前条转发的条件不满足
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardB</span> <span class="o">=</span> <span class="mh">01</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后一个判断条件是为了避免以下情况（前两条指令都是以关联寄存器为目的寄存器的时候，需要转发最新的数据，其数据来源是前一条，而不是前前条）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$1</span><span class="p">,</span><span class="no">$1</span><span class="p">,</span><span class="no">$2</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$1</span><span class="p">,</span><span class="no">$1</span><span class="p">,</span><span class="no">$3</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">$1</span><span class="p">,</span><span class="no">$1</span><span class="p">,</span><span class="no">$4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>综上可知，EX阶段的forward单元可以描述为（以操作数1为例）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">always</span> <span class="p">@(</span><span class="o">*</span><span class="p">)</span> <span class="k">begin</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span><span class="p">(</span><span class="n">ForwardA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="mh">00</span><span class="o">:</span><span class="n">ALU_op1</span> <span class="o">&lt;=</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">op1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="mh">01</span><span class="o">:</span><span class="n">ALU_op1</span> <span class="o">&lt;=</span> <span class="n">MEM_WB</span><span class="p">.</span><span class="n">wb_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="mh">10</span><span class="o">:</span><span class="n">ALU_op1</span> <span class="o">&lt;=</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">alu_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span><span class="o">:</span><span class="n">ALU_op1</span> <span class="o">&lt;=</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">op1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">endcase</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="lw-sw-type">lw-sw type<a href="#lw-sw-type" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>若sw的前条为lw，则可能需要从MEM/WB寄存器中转发至MEM阶段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">!=</span> <span class="mh">0</span> <span class="c1">// 不能使用0寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">and</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">MemWrite</span> <span class="c1">// 需要写入存储器(sw)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">and</span> <span class="n">MEM_WB</span><span class="p">.</span><span class="n">MemRead</span> <span class="c1">// 需要读取存储器(lw)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">and</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="o">==</span> <span class="n">MEM_WB</span><span class="p">.</span><span class="n">RegWrAddr</span> <span class="c1">// 转发源和转发目标的寄存器编号一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ForwardA</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>综上可知，MEM阶段的forward单元可以描述为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">always</span> <span class="p">@(</span><span class="o">*</span><span class="p">)</span> <span class="k">begin</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span><span class="p">(</span><span class="n">Forward</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="mh">0</span><span class="o">:</span><span class="n">Mem_Write_Data</span> <span class="o">&lt;=</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">op2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="mh">1</span><span class="o">:</span><span class="n">Mem_Write_Data</span> <span class="o">&lt;=</span> <span class="n">MEM_WB</span><span class="p">.</span><span class="n">Mem_Read_Data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">endcase</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="beq">beq<a href="#beq" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>若beq的前前一条指令为R type，则需要将EX_MEM中的ALU计算结果转发至ID阶段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegWrite</span> <span class="c1">// 需要写入寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">and</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF_ID</span><span class="p">.</span><span class="n">RegisterRs</span> <span class="c1">// 需要用到寄存器中的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Forward</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>综上可知，ID阶段的forward单元可以描述为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">always</span> <span class="p">@(</span><span class="o">*</span><span class="p">)</span> <span class="k">begin</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span><span class="p">(</span><span class="n">Forward</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="mh">0</span><span class="o">:</span><span class="n">compare_op1</span> <span class="o">&lt;=</span> <span class="n">regA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="mh">1</span><span class="o">:</span><span class="n">compare_op1</span> <span class="o">&lt;=</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">alu_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">endcase</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="hazard-unit">Hazard Unit<a href="#hazard-unit" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="lw-r-type">lw-R type<a href="#lw-r-type" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ID</span><span class="o">/</span><span class="n">EX</span><span class="p">.</span><span class="n">MemRead</span> <span class="c1">// 是否为load指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">and</span> <span class="p">((</span><span class="n">ID</span><span class="o">/</span><span class="n">EX</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF</span><span class="o">/</span><span class="n">ID</span><span class="p">.</span><span class="n">RegisterRs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="k">or</span> <span class="p">(</span><span class="n">ID</span><span class="o">/</span><span class="n">EX</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF</span><span class="o">/</span><span class="n">ID</span><span class="p">.</span><span class="n">RegisterRt</span><span class="p">))</span> <span class="p">)</span>  <span class="c1">// EX级的装载指令的目的寄存器是否与在ID级指令的某一个源寄存器相匹配（可能会发生冒险）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stall</span> <span class="o">=</span> <span class="mh">5</span><span class="mb">&#39;b11000</span><span class="p">;</span> <span class="c1">// stall IF and ID
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="beq-1">beq<a href="#beq-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">ID</span><span class="p">.</span><span class="n">branch</span> <span class="c1">// 分支指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">and</span> <span class="p">((</span><span class="n">ID_EX</span><span class="p">.</span><span class="n">RegWrite</span> <span class="k">and</span> <span class="p">(</span><span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF_ID</span><span class="p">.</span><span class="n">RegisterRs</span> <span class="k">or</span> <span class="n">ID_EX</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF_ID</span><span class="p">.</span><span class="n">RegisterRt</span><span class="p">)))</span> <span class="c1">// R type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">and</span> <span class="p">((</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">MemRead</span> <span class="k">and</span> <span class="p">(</span><span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF_ID</span><span class="p">.</span><span class="n">RegisterRs</span> <span class="k">or</span> <span class="n">EX_MEM</span><span class="p">.</span><span class="n">RegisterRd</span> <span class="o">==</span> <span class="n">IF_ID</span><span class="p">.</span><span class="n">RegisterRt</span><span class="p">)))</span> <span class="c1">// lw 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">stall</span> <span class="o">=</span> <span class="mh">5</span><span class="mb">&#39;b11000</span><span class="p">;</span> <span class="c1">// stall IF and ID
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>当 beq 前一条指令为 lw 指令时，我们阻塞流水线一个周期，在 lw 和 beq 中间插入一个气泡。此时这一情况自动退化为前前一条指令为 lw 的情况，会被上述逻辑再次处理，因此最终还是会完成 2 个周期的阻塞。</p>
</blockquote>
<h2 id="flush-unit">Flush Unit<a href="#flush-unit" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>使用<code>flush[i]</code>清除第<code>i</code>级流水线上执行的指令（对应4级流水寄存器以及最终写回的寄存器堆）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-verilog" data-lang="verilog"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">flush</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">begin</span>
</span></span><span class="line"><span class="cl">    <span class="n">stage_reg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mh">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="流水线cpu异常处理">流水线CPU异常处理<a href="#流水线cpu异常处理" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>假设有3种异常：badop，IRQ（外部中断），ALUExp。</p>
<p>Exception被放置在EX阶段，因此badop要经过一次ID/EX寄存器。</p>
<p>触发异常时，该单元会flush掉当前指令的EX/MEM寄存器，下条指令的ID/EX寄存器，下下条指令的IF/ID寄存器。（注意flush由hazard和exception单元共同控制）</p>
<h1 id="扩展技术">扩展技术<a href="#扩展技术" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h2 id="指令级并行">指令级并行<a href="#指令级并行" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="超级流水线">超级流水线<a href="#超级流水线" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>用于缩短时钟周期。</p>
<h3 id="多发射">多发射<a href="#多发射" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>用于降低CPI。</p>
<ul>
<li>
<p><strong>超长指令字</strong> 静态决定让哪些指令同时执行（在编译阶段由编译器决定）。</p>
</li>
<li>
<p><strong>超标量</strong> 动态决定哪些指令同时执行 （在运行时由硬件决定）。</p>
<p><img src="https://s2.loli.net/2022/06/15/6StxiOn9mB8sNej.png" alt="RAW,WAW,WAR"></p>
<blockquote>
<p>IOI-IOC,IOI-OOC,OOI-OOC</p>
</blockquote>
</li>
</ul>
<h2 id="线程级并行">线程级并行<a href="#线程级并行" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<h3 id="超线程">超线程<a href="#超线程" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h3 id="多核处理器">多核处理器<a href="#多核处理器" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>$a$为并行部分的比例，$n$为并行部分的加速比。
$$
S=\frac{1}{(1-a)+\frac{a}{n}}
$$</p>
<h2 id="异构计算">异构计算<a href="#异构计算" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>单指令流多数据流，具有更大的并行度，设计相对比较简单。</p>

      </div></div>

  

  
  

  
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://ther-nullptr.github.io/assets/main.js"></script>
<script src="https://ther-nullptr.github.io/assets/prism.js"></script>







  
</div>

</body>
</html>
