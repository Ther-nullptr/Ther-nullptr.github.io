<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>study :: Ther&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://ther-nullptr.github.io/categories/study/" />




<link rel="stylesheet" href="https://ther-nullptr.github.io/assets/style.css">

  <link rel="stylesheet" href="assets/%25!s%28%3cnil%3e%29.css">






<link rel="apple-touch-icon" href="https://ther-nullptr.github.io/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://ther-nullptr.github.io/">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="website" />
<meta property="og:title" content="study">
<meta property="og:description" content="" />
<meta property="og:url" content="https://ther-nullptr.github.io/categories/study/" />
<meta property="og:site_name" content="Ther&#39;s Blog" />

  
    <meta property="og:image" content="https://ther-nullptr.github.io/">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">





  <link href="/categories/study/index.xml" rel="alternate" type="application/rss+xml" title="Ther&#39;s Blog" />









</head>
<body class="">


<div class="container headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="https://ther-nullptr.github.io/">
  <div class="logo">
    Terminal
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/posts/">Home</a></li>
        
      
        
          <li><a href="/about/">About</a></li>
        
      
        
          <li><a href="/archives/">Archives</a></li>
        
      
        
          <li><a href="/search/">Search</a></li>
        
      
        
          <li><a href="/links/">Links</a></li>
        
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/posts/">Home</a></li>
      
    
      
        <li><a href="/about/">About</a></li>
      
    
      
        <li><a href="/archives/">Archives</a></li>
      
    
      
        <li><a href="/search/">Search</a></li>
      
    
      
        <li><a href="/links/">Links</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
  
  <div class="posts">
    
      <div class="post on-list">
        <h1 class="post-title">
          <a href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/multicycle_cpu/">Multicycle CPU</a>
        </h1>
        <div class="post-meta">
          <span class="post-date">
            2022-06-04
          </span>
          
        </div>

        
          <span class="post-tags">
            
            #<a href="https://ther-nullptr.github.io/tags/digital-logic-and-processors/">digital logic and processors</a>&nbsp;
            
          </span>
        

        


      
        <div class="post-content">
          
            多周期CPU 多周期数据通路     R lw or sw beq J     IF PC&lt;=PC+4; IR &lt;=MemInst[PC]; * * *   ID opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]]; ALUOut&lt;=PC+(signext(IR[15:0]«2)) * * *   EX ALUOut &lt;= A op B ALUOut&lt;=A+sign-ext(IR[15:0]) if (A=B)PC&lt;=ALUOut PC &lt;= {PC[31:28],IR[25:0],2’b00}   MEM Reg[IR[15:11]]&lt;=ALUOut Lw:MDR&lt;=MemData[ALUOut];Sw:MemData[ALUout] &lt;=B     WB  Reg[IR[20:16]]&lt;=MDR      重点控制信号的周期：
IRWrite：在Instruction fench阶段被置为1，但在lw的Memory access阶段被置为0，因为在lw的Register writeback阶段，Instruction Register不能再更新，如果更新的话，会被读出的数据覆盖。 MemRead：在Instruction fench阶段被置为1（用于读取指令），在Instruction decode阶段为0，在lw的Memory access阶段被置为1。 MemWrite：默认0，在sw的Memory access阶段被置为1。 ALUSrc1：在Instruction fench阶段为00（PC），在Execution阶段根据实际情况修改。 ALUSrc2：在Instruction fench阶段为01（4），在Instruction decode阶段为11（imm«2），在Execution阶段根据实际情况修改。 PCWrite：在Instruction fench阶段为1（PC&lt;=PC+4），在Instruction decode阶段为0，此后若执行跳转类指令则被置为1。 PCSource：默认为00（PC&lt;=PC+4），在Execution阶段视情况改变。 IorD：默认0（取指令），在Memory access阶段被置为1。 PCWriteCond：在beq的Execution阶段被置为1。 MemtoReg：默认00。 RegDst：默认00。 RegWrite：默认0，在jal和jalr以及Register writeback中被置为1。 ExtOp：在Instruction decode阶段被置为1，因为需要算跳转地址。 ALUOp：在Instruction fench和Instruction decode均为00，因为需要执行加法操作；R type被置为10，beq被置为01。  多周期异常和中断处理 异常指内部不可预知事件（溢出，同步），中断指外部不可预知事件（I/O，异步）。
          
        </div>

        
        <div>
          <a class="read-more button"
            href="/posts/digital_logic_and_processors/multicycle_cpu/"> →</a>
        </div>
        
      </div>
    
      <div class="post on-list">
        <h1 class="post-title">
          <a href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/control_signal/">CPU中的控制信号</a>
        </h1>
        <div class="post-meta">
          <span class="post-date">
            2022-06-04
          </span>
          
        </div>

        
          <span class="post-tags">
            
            #<a href="https://ther-nullptr.github.io/tags/digital-logic-and-processors/">digital logic and processors</a>&nbsp;
            
          </span>
        

        


      
        <div class="post-content">
          
            控制信号常见答疑 About Extop <a href="https://stackoverflow.com/questions/55290060/what-does-extend-immediate-to-32-bits-mean-in-mips">https://stackoverflow.com/questions/55290060/what-does-extend-immediate-to-32-bits-mean-in-mips</a>
I-type instructions with 16-bit immediates are different.
addi / addiu immediates are sign-extended (by duplicating the top/sign bit of the immediate to all higher bits). <a href="https://en.wikipedia.org/wiki/Two%27s_complement#Sign_extension">https://en.wikipedia.org/wiki/Two%27s_complement#Sign_extension</a> This allows 2’s complement numbers from -2^15 .. +2^15-1 to be encoded. (0xFFFF8000 to 0x00007FFF) ori/andi/xori boolean immediates are zero-extended (by setting all higher bits to zero) This allows unsigned / 2’s complement numbers from 0 .. 2^16-1 to be encoded.
          
        </div>

        
        <div>
          <a class="read-more button"
            href="/posts/digital_logic_and_processors/control_signal/"> →</a>
        </div>
        
      </div>
    
      <div class="post on-list">
        <h1 class="post-title">
          <a href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/assembly/">MIPS汇编语言</a>
        </h1>
        <div class="post-meta">
          <span class="post-date">
            2022-06-03
          </span>
          
        </div>

        
          <span class="post-tags">
            
            #<a href="https://ther-nullptr.github.io/tags/digital-logic-and-processors/">digital logic and processors</a>&nbsp;
            
          </span>
        

        


      
        <div class="post-content">
          
            处理器 处理器架构  普林斯顿架构：存储器同时存储指令和其他数据 哈佛架构：数据存储和指令存储分开  处理器性能 执行时间 = 指令数 x CPI x 时钟周期
或： $$ CPI = CPI_1\times p_1+…+CPI_n\times p_n $$ 性能提升方法：
优化编译技术（减少指令数） 快速电路技术或更为先进的电路结构（减少时钟周期）  寄存器 VS 存储器  寄存器：以编号进行访问，可同时访问不同寄存器。 存储器：以地址进行访问，不可同时访问不同地址，相邻数据的地址相差4字节。  数据单位约定 在32位MIPS中，1 word = 4 bytes = 32 bits，相邻数据的地址相差4字节。
1 2 3 4 5 6 7 8 9 10 11  #include&lt;stdio.h&gt;int main() { printf(&quot;%d\n&quot;,sizeof(int)); // 4  printf(&quot;%d\n&quot;,sizeof(char)); // 1  printf(&quot;%d\n&quot;,sizeof(unsigned int)); // 4  printf(&quot;%d\n&quot;,sizeof(long int)); // 8  printf(&quot;%d\n&quot;,sizeof(long long int)); // 8  printf(&quot;%d\n&quot;,sizeof(float)); // 4  printf(&quot;%d\n&quot;,sizeof(double)); // 8 }   MIPS汇编指令 汇编优化相关问题   算数&amp;逻辑指令11bit冗余能否利用起来？
          
        </div>

        
        <div>
          <a class="read-more button"
            href="/posts/digital_logic_and_processors/assembly/"> →</a>
        </div>
        
      </div>
    
      <div class="post on-list">
        <h1 class="post-title">
          <a href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/memory/">Cache</a>
        </h1>
        <div class="post-meta">
          <span class="post-date">
            2022-05-31
          </span>
          
        </div>

        
          <span class="post-tags">
            
            #<a href="https://ther-nullptr.github.io/tags/digital-logic-and-processors/">digital logic and processors</a>&nbsp;
            
          </span>
        

        


      
        <div class="post-content">
          
            Memory RAM random access是指该存储器的所有内容都可以被读取和写入，且与时间和位置无关。
SRAM DRAM     中文名 静态随机访问存储器 动态随机访问存储器   速度 快 慢（需要读取内容后刷新、定期刷新）   结构 由MOS管组成的锁存器（6T） 由MOS管和电容实现（1T1C）   容量 小 大   应用 缓存 主存   访问时间 1~10ns 10~100ns    常见问答：
DRAM电容量C的权衡：
大电容容量C的优势：提供更长的数据保持时间 大电容容量C的劣势：工艺实现难度加大，密度降低    RAS和CAS均为低电平有效，其中CAS可以作为输出使能信号。
cache 原理 存储系统满足局部性原理：
时间局部性——最近的将来要用到的信息很可能就是现在正在使用的信息。主要由循环造成。 空间局部性——最近的将来要用到的信息很可能与现在正在使用的信息在空间上是邻近的。主要由顺序执行和数据的聚集存放造成。  cache的访问时间 一级cache（$r$为访问时间比，$e$为访问效率）： $$ T_A=T_{A1}+(1-H)T_{A2}\ r=\frac{T_{A2}}{T_{A1}}\ e=\frac{T_{A1}}{T_A} = \frac{1}{1+(1-H)r} $$ 二级cache： $$ T_A=T_{A1}+(1-H_1)[T_{A2}+(1-H_2)T_{A3}] $$
          
        </div>

        
        <div>
          <a class="read-more button"
            href="/posts/digital_logic_and_processors/memory/"> →</a>
        </div>
        
      </div>
    
      <div class="post on-list">
        <h1 class="post-title">
          <a href="https://ther-nullptr.github.io/posts/digital_logic_and_processors/pipeline_cpu/">Pipeline CPU</a>
        </h1>
        <div class="post-meta">
          <span class="post-date">
            2022-05-31
          </span>
          
        </div>

        
          <span class="post-tags">
            
            #<a href="https://ther-nullptr.github.io/tags/digital-logic-and-processors/">digital logic and processors</a>&nbsp;
            
          </span>
        

        


      
        <div class="post-content">
          
            流水线计算公式 $n$为指令数，$k$为流水线级数，级间延时$\Delta t$。
实际吞吐率（单位时间内流水线处理的指令数）： $$ TP=\frac{n}{(k+n-1)\Delta t} $$ 最大吞吐率： $$ TP_{max} = \frac{1}{\Delta t} $$ 实际加速比： $$ S = \frac{kn}{k+n-1} $$ 最大加速比： $$ S_{max}=k $$
流水线中控制信号的流动 控制信号在IF之后的ID/RF阶段产生。
ID/RF：Extop EX：ALUSrc、ALUOp、RegDst？？ MEM：MemWrite、Branch WB：MemToReg、RegWrite  流水线中的冒险 首先列出未冒险时流水线CPU在各步中进行的操作：
R lw or sw beq J     IF PC&lt;=PC+4; IR &lt;=MemInst[PC] * * *   ID opcode&lt;=IR[31:26]; A&lt;=Reg[IR[25:21]]; B&lt;=Reg[IR[20:16]]; ALUOut&lt;=PC+(signext(IR[15:0]&lt;&lt;2)) * * PC &lt;= {PC[31:28],IR[25:0],2’b00}   EX ALUOut &lt;= A op B ALUOut&lt;=A+sign-ext(IR[15:0]) if (A=B)PC&lt;=ALUOut    MEM Reg[IR[15:11]]&lt;=ALUOut Lw:MDR&lt;=MemData[ALUOut];Sw:MemData[ALUout] &lt;=B     WB  Reg[IR[20:16]] &lt;=MDR      结构冒险 problem 流水线处理器中直接取消了InstMemory和DataMemory混用的做法，因此不必担心存储器访问的冲突。
          
        </div>

        
        <div>
          <a class="read-more button"
            href="/posts/digital_logic_and_processors/pipeline_cpu/"> →</a>
        </div>
        
      </div>
    
    <div class="pagination">
  <div class="pagination__buttons">
    
    
  </div>
</div>

  </div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://ther-nullptr.github.io/assets/main.js"></script>
<script src="https://ther-nullptr.github.io/assets/prism.js"></script>







  
</div>

</body>
</html>
